var documenterSearchIndex = {"docs":
[{"location":"#RadioClock.jl","page":"Introduction","title":"RadioClock.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This is the reference documentation of RadioClock.jl.","category":"page"},{"location":"#Index","page":"Introduction","title":"Index","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"#Time-signals","page":"Introduction","title":"Time signals","text":"","category":"section"},{"location":"#DCF77","page":"Introduction","title":"DCF77","text":"","category":"section"},{"location":"#RadioClock.DCF77","page":"Introduction","title":"RadioClock.DCF77","text":"DCF77 <: RadioSignal\n\nType used for dispatch for functions related to the DCF77 time signal (e.g. decode(::Type{DCF77}, data::DCF77Data) and encode(::Type{DCF77}, zdt::ZonedDateTime)). This struct does not hold any data, see DCF77Data for that instead.\n\n\n\n\n\n","category":"type"},{"location":"#RadioClock.DCF77Data","page":"Introduction","title":"RadioClock.DCF77Data","text":"DCF77Data(x)\n\nContainer for DCF77 radio signal data.\n\nThis struct holds the raw 60-bit DCF77 signal data as a UInt64. The top 4 bits must be zero, leaving 60 bits for the actual signal data.\n\nFields\n\nx::UInt64: The raw signal data\n\nConstructors\n\nDCF77Data(x::UInt64): Create from a 64-bit unsigned integer\nDCF77Data(str::String): Create from a binary string representation\n\nExamples\n\njulia> using RadioClock\n\njulia> DCF77Data(0x00a05c6908340000)\nDate: 2028-02-06T08:41:00+01:00\nBinary representation: 000000000000000000101100000100001001011000111010000001010000\n\njulia> DCF77Data(\"000000000000000000101100000100001001011000111010000001010000\")\nDate: 2028-02-06T08:41:00+01:00\nBinary representation: 000000000000000000101100000100001001011000111010000001010000\n\njulia> DCF77Data(\"000000000000000000101100111001100011000010100100000100010010\")\nDate: 2022-01-10T23:39:00+01:00\nBinary representation: 000000000000000000101100111001100011000010100100000100010010\n\njulia> DCF77Data(\"000000000000000001001011011000000101100101011100101000000001\")\nDate: Invalid date\nBinary representation: 000000000000000001001011011000000101100101011100101000000001\n\n\n\n\n\n","category":"type"},{"location":"#RadioClock.decode-Tuple{Type{DCF77}, DCF77Data}","page":"Introduction","title":"RadioClock.decode","text":"RadioClock.decode(DCF77, data::Union{DCF77Data,UInt64,String}) :: TimeZones.ZonedDateTime\n\nDecode DCF77 signal data into a TimeZones.ZonedDateTime.\n\nParses the DCF77 signal according to the official specification and returns a timezone-aware datetime object. Performs various consistency checks to ensure data integrity.\n\nArguments\n\nDCF77: The signal type (DCF77)\ndata: The DCF77 signal data to decode, as a DCF77Data, or as a UInt64 or a String, which will be automatically converted to DCF77Data\n\nReturns\n\nA TimeZones.ZonedDateTime representing the decoded time and date in the Europe/Berlin timezone\n\nErrors\n\nThrows AssertionError if any validation fails, indicating corrupted or invalid signal data.\n\nExamples\n\njulia> using RadioClock\n\njulia> RadioClock.decode(DCF77, DCF77Data(\"000000000000000001001110010100000000111001011000010001100010\"))\n2018-10-27T00:53:00+02:00\n\njulia> RadioClock.decode(DCF77, \"000000000000000001001101010010000011010010111111001110110010\")\n2037-07-12T20:15:00+02:00\n\njulia> RadioClock.decode(DCF77, DCF77Data(\"000000000000000001101011000110100001100010001100011000010010\"))\nERROR: AssertionError: CET/CEST data is inconsistent. Input was 0x486311858d60000\n[...]\n\njulia> RadioClock.decode(DCF77, \"000000000000000001001111001000100100000100001101001000110000\")\nERROR: AssertionError: Date data is not consistent with parity check. Input was 0xc4b08244f20000\n[...]\n\njulia> RadioClock.decode(DCF77, \"000000000000000001001111010110100001011001111000010001000000\")\nERROR: AssertionError: Summer time announcement bit (false) is not consistent with date (2008-10-26T02:57:00+02:00). Input was 0x221e685af20000\n[...]\n\nNotes\n\nCurrently this assumes the year is in the 21st century (2000-2099), as the DCF77 signal is ambiguous about the century\nThe inverse of this function is encode(::Type{DCF77}, zdt::ZonedDateTime)\n\n\n\n\n\n","category":"method"},{"location":"#RadioClock.encode-Tuple{Type{DCF77}, ZonedDateTime}","page":"Introduction","title":"RadioClock.encode","text":"RadioClock.encode(DCF77, zdt::TimeZones.ZonedDateTime) :: DCF77Data\nRadioClock.encode(DCF77, year::Integer, month::Integer, day::Integer, hour::Integer, minute::Integer) :: DCF77Data\n\nEncode a TimeZones.ZonedDateTime using the DCF77 format.\n\nArguments\n\nDCF77: The signal type (DCF77)\nthe date time in the German time zone as either\na single zdt::TimeZones.ZonedDateTime object, representing the date time\nor the sequence of the individual date time parts year::Integer, month::Integer, day::Integer, hour::Integer, minute::Integer\n\nReturns\n\nA DCF77Data object, holding the DCF77-like signal data\n\nExamples\n\njulia> using RadioClock, TimeZones\n\njulia> RadioClock.encode(DCF77, ZonedDateTime(2014, 3, 30, 1, 18, tz\"Europe/Berlin\", 1))\nDate: 2014-03-30T01:18:00+01:00\nBinary representation: 000000000000000010101000110001000001000011111110000010100010\n\njulia> RadioClock.encode(DCF77, 2010, 9, 2, 6, 19)\nDate: 2010-09-02T06:19:00+02:00\nBinary representation: 000000000000000001001100110010110000010000001100100000100010\n\nNotes\n\nThe inverse of this function, for dates within the 21st century, is decode(::Type{DCF77}, data::DCF77Data)\n\n\n\n\n\n","category":"method"},{"location":"#Internal-utilities,-non-public-API","page":"Introduction","title":"Internal utilities, non-public API","text":"","category":"section"},{"location":"#RadioClock.extract_bits","page":"Introduction","title":"RadioClock.extract_bits","text":"extract_bits(x::Integer, lo::Int, hi::Int)\n\nExtract a range of bits from an integer.\n\nExtracts hi - lo + 1 bits starting from bit position lo (inclusive) to bit position hi (inclusive). The result is returned as an unsigned integer.\n\nArguments\n\nx::Integer: The input integer to extract bits from\nlo::Int: The lowest bit position to extract (0-based, inclusive)\nhi::Int: The highest bit position to extract (0-based, inclusive)\n\nReturns\n\nAn unsigned integer containing the extracted bits\n\nExamples\n\njulia> using RadioClock: extract_bits\n\njulia> extract_bits(0b101010, 3, 5)\n0x0000000000000005\n\njulia> bitstring(ans)\n\"0000000000000000000000000000000000000000000000000000000000000101\"\n\njulia> extract_bits(0x12345678, 0, 7)\n0x0000000000000078\n\njulia> extract_bits(0x12345678, 16, 23)\n0x0000000000000034\n\nNotes\n\nBit positions are 0-based (least significant bit is position 0)\nThe function creates a mask for the specified bit range and applies it after shifting\nUseful for parsing binary data formats\n\n\n\n\n\n","category":"function"},{"location":"#RadioClock.decode_2digit_bcd","page":"Introduction","title":"RadioClock.decode_2digit_bcd","text":"decode_2digit_bcd(x::UInt64) :: UInt64\n\nDecode a 2-digit decimal integer encoded with the BCD (Binary-Coded Decimal) format.\n\nBCD encoding stores each decimal digit as a 4-bit binary number, so a 2-digit number requires 8 bits total.\n\nArguments\n\nx::UInt64: The input integer containing the BCD-encoded data\n\nReturns\n\nThe integer âˆˆ [0, 99] representing the decoded decimal value of the input number, as a UInt64\n\nExamples\n\njulia> using RadioClock: decode_2digit_bcd\n\njulia> decode_2digit_bcd(UInt64(0x23))\n0x0000000000000017\n\njulia> Int(ans)\n23\n\nNotes\n\nAssumes the input is a valid 2-digit BCD number in the range [0, 99]\nThe high nibble (bits 4-7) represents the tens digit\nThe low nibble (bits 0-3) represents the ones digit\nThe inverse of this function is encode_bcd\n\n\n\n\n\n","category":"function"},{"location":"#RadioClock.encode_bcd","page":"Introduction","title":"RadioClock.encode_bcd","text":"encode_bcd(x::Integer) :: UInt64\n\nEncode an integer using the BCD (Binary-Coded Decimal) format.\n\nArguments\n\nx::Integer: The input integer to be encoded\n\nReturns\n\nThe BCD encoding of the input number as a UInt64 number\n\nExamples\n\njulia> using RadioClock: encode_bcd\n\njulia> encode_bcd(123)\n0x0000000000000123\n\njulia> encode_bcd(4296)\n0x0000000000004296\n\nNotes\n\nThe inverse of this function, for 2-digit decimal integers only, is decode_2digit_bcd\n\n\n\n\n\n","category":"function"},{"location":"#RadioClock.parity","page":"Introduction","title":"RadioClock.parity","text":"parity(x::Integer) :: Bool\n\nCalculate the (odd) parity for a range of bits.\n\nReturns true if the number of 1-bits is odd, false if it's even. This is used for error detection in data transmission.\n\nArguments\n\nx::Integer: The input integer to check parity for\n\nReturns\n\ntrue if the number of 1-bits is odd\nfalse if the number of 1-bits is even\n\nExamples\n\njulia> using RadioClock: parity\n\njulia> parity(0b101010)\ntrue\n\njulia> parity(0b011101)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"#RadioClock.RadioSignal","page":"Introduction","title":"RadioClock.RadioSignal","text":"RadioSignal\n\nAbstract type representing radio time signals.\n\n\n\n\n\n","category":"type"}]
}
