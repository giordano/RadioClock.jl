var documenterSearchIndex = {"docs":
[{"location":"#RadioClock.jl","page":"Introduction","title":"RadioClock.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This is the reference documentation of RadioClock.jl.","category":"page"},{"location":"#Index","page":"Introduction","title":"Index","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"#Time-signals","page":"Introduction","title":"Time signals","text":"","category":"section"},{"location":"#DCF77","page":"Introduction","title":"DCF77","text":"","category":"section"},{"location":"#RadioClock.DCF77","page":"Introduction","title":"RadioClock.DCF77","text":"DCF77 <: RadioSignal\n\nType used for dispatch for function related to the DCF77 time signal.\n\n\n\n\n\n","category":"type"},{"location":"#RadioClock.DCF77Data","page":"Introduction","title":"RadioClock.DCF77Data","text":"DCF77Data(x)\n\nContainer for DCF77 radio signal data.\n\nThis struct holds the raw 60-bit DCF77 signal data as a UInt64. The top 4 bits must be zero, leaving 60 bits for the actual signal data.\n\nFields\n\nx::UInt64: The raw signal data\n\nConstructors\n\nDCF77Data(x::UInt64): Create from a 64-bit unsigned integer\nDCF77Data(str::String): Create from a binary string representation\n\nExamples\n\njulia> using RadioClock\n\njulia> DCF77Data(0x00a05c6908340000)\nDate: 2028-02-06T08:41:00+01:00\nBinary representation: 000000000000000000101100000100001001011000111010000001010000\n\njulia> DCF77Data(\"000000000000000000101100000100001001011000111010000001010000\")\nDate: 2028-02-06T08:41:00+01:00\nBinary representation: 000000000000000000101100000100001001011000111010000001010000\n\njulia> DCF77Data(\"000000000000000000101100111001100011000010100100000100010010\")\nDate: 2022-01-10T23:39:00+01:00\nBinary representation: 000000000000000000101100111001100011000010100100000100010010\n\njulia> DCF77Data(\"000000000000000001001011011000000101100101011100101000000001\")\nDate: Invalid date\nBinary representation: 000000000000000001001011011000000101100101011100101000000001\n\n\n\n\n\n","category":"type"},{"location":"#RadioClock.decode-Tuple{Type{DCF77}, DCF77Data}","page":"Introduction","title":"RadioClock.decode","text":"RadioClock.decode(DCF77, data::Union{DCF77Data,UInt64,String})\n\nDecode DCF77 signal data into a TimeZones.ZonedDateTime.\n\nParses the DCF77 signal according to the official specification and returns a timezone-aware datetime object. Performs various consistency checks to ensure data integrity.\n\nArguments\n\nDCF77: The signal type (DCF77)\ndata: The DCF77 signal data to decode, as a DCF77Data, or as a UInt64 or a String, which will be automatically converted to DCF77Data\n\nReturns\n\nA TimeZones.ZonedDateTime representing the decoded time and date in the Europe/Berlin timezone\n\nErrors\n\nThrows AssertionError if any validation fails, indicating corrupted or invalid signal data.\n\nExamples\n\njulia> using RadioClock\n\njulia> RadioClock.decode(DCF77, DCF77Data(\"000000000000000001001110010100000000111001011000010001100010\"))\n2018-10-27T00:53:00+02:00\n\njulia> RadioClock.decode(DCF77, \"000000000000000001001101010010000011010010111111001110110010\")\n2037-07-12T20:15:00+02:00\n\njulia> RadioClock.decode(DCF77, DCF77Data(\"000000000000000001101011000110100001100010001100011000010010\"))\nERROR: AssertionError: CET/CEST data is inconsistent\n[...]\n\njulia> RadioClock.decode(DCF77, \"000000000000000001001111001000100100000100001101001000110000\")\nERROR: AssertionError: Date data is not consistent with parity check\n[...]\n\nNotes\n\nCurrently this assumes the year is in the 21st century (2000-2099), as the DCF77 signal is ambiguous about the century\n\n\n\n\n\n","category":"method"},{"location":"#Internal-utilities,-non-public-API","page":"Introduction","title":"Internal utilities, non-public API","text":"","category":"section"},{"location":"#RadioClock.extract_bits","page":"Introduction","title":"RadioClock.extract_bits","text":"extract_bits(x::Integer, lo::Int, hi::Int)\n\nExtract a range of bits from an integer.\n\nExtracts hi - lo + 1 bits starting from bit position lo (inclusive) to bit position hi (inclusive). The result is returned as an unsigned integer.\n\nArguments\n\nx::Integer: The input integer to extract bits from\nlo::Int: The lowest bit position to extract (0-based, inclusive)\nhi::Int: The highest bit position to extract (0-based, inclusive)\n\nReturns\n\nAn unsigned integer containing the extracted bits\n\nExamples\n\njulia> using RadioClock: extract_bits\n\njulia> extract_bits(0b101010, 3, 5)\n0x0000000000000005\n\njulia> bitstring(ans)\n\"0000000000000000000000000000000000000000000000000000000000000101\"\n\njulia> extract_bits(0x12345678, 0, 7)\n0x0000000000000078\n\njulia> extract_bits(0x12345678, 16, 23)\n0x0000000000000034\n\nNotes\n\nBit positions are 0-based (least significant bit is position 0)\nThe function creates a mask for the specified bit range and applies it after shifting\nUseful for parsing binary data formats\n\n\n\n\n\n","category":"function"},{"location":"#RadioClock.decode_2digit_bcd","page":"Introduction","title":"RadioClock.decode_2digit_bcd","text":"decode_2digit_bcd(x::UInt64)\n\nDecode a 2-digit BCD (Binary-Coded Decimal) number from an integer.\n\nBCD encoding stores each decimal digit as a 4-bit binary number, so a 2-digit number requires 8 bits total.\n\nArguments\n\nx::UInt64: The input integer containing the BCD-encoded data\n\nReturns\n\nAn integer representing the decoded decimal value (0-99)\n\nExamples\n\njulia> using RadioClock: decode_2digit_bcd\n\njulia> Int(decode_2digit_bcd(UInt64(0x23)))\n23\n\nNotes\n\nAssumes the input is a valid 2-digit BCD number in the range [0, 99]\nThe high nibble (bits 4-7) represents the tens digit\nThe low nibble (bits 0-3) represents the ones digit\n\n\n\n\n\n","category":"function"},{"location":"#RadioClock.parity","page":"Introduction","title":"RadioClock.parity","text":"parity(x::Integer)\n\nCalculate the (odd) parity for a range of bits.\n\nReturns true if the number of 1-bits is odd, false if it's even. This is used for error detection in data transmission.\n\nArguments\n\nx::Integer: The input integer to check parity for\n\nReturns\n\ntrue if the number of 1-bits is odd\nfalse if the number of 1-bits is even\n\nExamples\n\njulia> using RadioClock: parity\n\njulia> parity(0b101010)\ntrue\n\njulia> parity(0b011101)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"#RadioClock.RadioSignal","page":"Introduction","title":"RadioClock.RadioSignal","text":"RadioSignal\n\nAbstract type representing radio time signals.\n\n\n\n\n\n","category":"type"}]
}
